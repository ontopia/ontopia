<?xml version="1.0" encoding="iso-8859-1" standalone="yes"?>
<!--DOCTYPE article PUBLIC "-//OASIS//DTD DocBook EBNF Module V1.0beta3//EN" '../../standards/tmpm/dummy.dtd'-->
<article>
<title>tolog</title>
<subtitle>Language tutorial</subtitle>

<articleinfo>
<author>
<affiliation><orgname>Ontopia</orgname></affiliation>
</author>
<pubdate>$Date: 2008/06/13 12:06:19 $</pubdate>
<releaseinfo>5.0 ($Revision: 1.38 $)</releaseinfo>

<abstract>
<para>
This document is a tutorial introduction to the tolog topic map query
language. It explains how to use all the features of the language, as
defined in version 1.2.
</para>
</abstract>
</articleinfo>


<section>
<title>Introduction</title>

<para>
tolog is a language for querying and updating topic maps, inspired by
Datalog (a subset of Prolog) and SQL. Using tolog one can query a
topic map in much the same way as a relational database can be queried
with SQL.  It is possible to ask for all topics of a particular types,
the names of all topics of a particular type in a particular scope,
for all topics used as association role types, for all associations
with more than two roles, and so on.
</para>

<para>
This tutorial will walk the reader through the use of tolog step by
step, and by the end of it all of tolog will have been covered.
</para>

<section>
<title>Predicates and variables</title>

<para>
tolog is a logic-based query language, which means that the basic
operation is for the user to ask tolog in which cases a certain
assertion holds true, and tolog will then respond with all the sets of
values that make the assertion true.
</para>

<para>
Assertions in tolog consist of <firstterm>predicates</firstterm>,
which are relationships between sets of values. A predicate can be
thought of as a table of all the sets of values that make it true, and
querying is done by matching the query against the table, returning
all sets of values that match.
</para>

<para>
One tolog predicate is the one known as <symbol>instance-of</symbol>,
which is used to query the topic instance-topic type relationship. One
query using this predicate might be:
</para>

<programlisting>
instance-of($TOPIC, $TYPE)?
</programlisting>

<para>
In this query there is only one predicate, and that has variables
being passed as both of its parameters. This means that we want
<emphasis>all</emphasis> combinations of values for these variables
that make the assertion true. That is, we want all combinations of
(topic, topic type) that are found in the topic map. If we ran this
query against <filename>opera.ltm</filename>
we might get a result like the following.
</para>

<table>
<title>All topics and types</title>
<tgroup cols="2">
<thead><row><entry>TOPIC</entry> <entry>TYPE</entry></row></thead>
<tbody>
<row><entry>RAI</entry>                <entry>organization</entry></row>
<row><entry>RAI</entry>                <entry>TV company</entry></row>
<row><entry>Teatro Nuovo</entry>       <entry>organization</entry></row>
<row><entry>Casinò di San Remo</entry> <entry>organization</entry></row>
<row><entry>Imperial Opera</entry>     <entry>organization</entry></row>
<row><entry>Teatro La Pariola</entry>  <entry>organization</entry></row>
<row><entry>...</entry>                <entry>...</entry></row>
</tbody>
</tgroup>
</table>

<para>
This shows all topics that have a type, and for each topic, all of its
types (which is why RAI appears twice; it is an instance of two
types).  The actual table of results is several hundred lines long.
</para>

<para>
Now, let's say we want to find all instances of the type
<symbol>theatre</symbol>. Recall that the previous query was as shown
below.
</para>

<programlisting>
instance-of($TOPIC, $TYPE)?
</programlisting>

<para>
This gave us all (topic, type) combinations because we had variables
as both parameters. In this case we don't want all possible types, we
just want the <symbol>theatre</symbol>, so we replace the variable by
that particular type. This gives us the query below.
</para>

<programlisting>
instance-of($TOPIC, theatre)?
</programlisting>

<para>
Now we are asking for all values of <symbol>TOPIC</symbol> that would
make the above true; that is, we are asking for all instances of
<symbol>theatre</symbol>.
</para>

<table>
<title>All theatres</title>
<tgroup cols="1">
<thead><row><entry>TOPIC</entry></row></thead>
<tbody>
<row><entry>Teatro Massimo</entry></row>
<row><entry>Teatro Bellini</entry></row>
<row><entry>Teatro San Carlo</entry></row>
<row><entry>Teatro La Pariola</entry></row>
<row><entry>Académie Royale de Musique</entry></row>
<row><entry>Teatro Pagliano</entry></row>
<row><entry>...</entry></row>
</tbody>
</tgroup>
</table>

<para>
Similarly, should we want to know all types of which a topic is an
instance we can replace the <symbol>TOPIC</symbol> variable with a
topic reference, and put in a variable as the second parameter, as
shown below.
</para>

<programlisting>
instance-of(teatro-massimo, $TYPE)?
</programlisting>

<para>
When run, this query gives the following results.
</para>

<table>
<title>All types of which Teatro Massimo is an instance</title>
<tgroup cols="1">
<thead><row><entry>TYPE</entry></row></thead>
<tbody>
<row><entry>Theatre</entry></row>
<row><entry>Organization</entry></row>
</tbody>
</tgroup>
</table>

<para>
We get 'Theatre', as expected, but also 'Organization', which may be
somewhat surprising. In the topic map the only type given for Teatro
Massimo is <symbol>theatre</symbol>, so what is
<symbol>organization</symbol> doing here? The answer is that
<symbol>organization</symbol> is defined as a supertype of
<symbol>theatre</symbol> in the topic map. This means that any
instance of <symbol>theatre</symbol> is also an instance of
<symbol>organization</symbol>. tolog knows this and makes use of the
information to make Teatro Massimo an instance of both types.
</para>

<para>
You should now be familiar with what a predicate is and what a
variables. From this point on we'll look at how to combine predicates
in more complex ways, more types of predicates, and also some ways of
processing the results of query.
</para>
</section>

<section>
<title>Dynamic association predicates</title>

<para>
As we said above, a predicate represents a relationship, and because
of this tolog allows topic map associations to be treated as
predicates. In this case the name of the predicate is the name of the
association type, and the values are the topics playing roles in
associations of this type. Given this we might expect to be able to
write the following query to find all operas composed by Puccini.
</para>

<programlisting>
composed-by(puccini, $OPERA)?
</programlisting>

<para>
However, this results in an error, because the tolog engine is not
able to work out which association role is played by
<symbol>puccini</symbol> and which by the <symbol>OPERA</symbol>.
This must be given explicitly in the query as shown below.
</para>

<programlisting>
composed-by(puccini : composer, $OPERA : opera)?
</programlisting>

<para>
Here it is made explicit that we want to find out when
<symbol>puccini</symbol> plays the role <symbol>composer</symbol> and
when the <symbol>OPERA</symbol> plays the role <symbol>opera</symbol>.
This syntax is <emphasis>only</emphasis> used for association
predicates, not for any other type of predicate. The result is as
shown below.
</para>

<table>
<title>All operas composed by Puccini</title>
<tgroup cols="1">
<thead><row><entry>OPERA</entry></row></thead>
<tbody>
<row><entry>Le Villi</entry></row>
<row><entry>Madame Butterfly</entry></row>
<row><entry>Tosca</entry></row>
<row><entry>Turandot</entry></row>
<row><entry>Manon Lescaut</entry></row>
<row><entry>La Bohème</entry></row>
<row><entry>...</entry></row>
</tbody>
</tgroup>
</table>

<para>
We can play around with the variables here in the same way as we did
for the <symbol>instance-of</symbol> predicate, and get all
combinations of opera and composer, and all composers for a specific
opera (say <symbol>tosca</symbol>). This is done in exactly the same
way, so we won't explain how here, but leave it as an exercise for the
reader. See <xref linkend="sect-plugin"/> to learn how to run tolog
queries in the Omnigator.
</para>
</section>

<section>
<title>AND</title>

<para>
If we want to find all cities located in Italy we know that this is
easy: we can just query the <symbol>located-in</symbol> association
type to find the city topics that have this association with the Italy
topic. Similarly, if we want to find everyone born in a particular
just query the <symbol>born-in</symbol> association type. 
</para>

<para>
But what if we want to find everyone born in a city located in Italy?
What we want in this case is something like what is shown below.
</para>

<programlisting>
born-in($PERSON : person, $PLACE : place) 
AND 
located-in($CITY : containee, italy : container)?
</programlisting>

<para>
This query is quite close to the correct one, but there are two
problems with it. First of all, the way to chain predicates together
with an AND condition is simply to put a comma between them. (You can
say that AND is the default boolean operator in tolog.) The second
problem is that we want to make sure that the <symbol>CITY</symbol>
located in Italy is the same as the <symbol>PLACE</symbol> where the
person is born. If we use the same variable in both places tolog will
take this to mean that the same values have to be used both places.
So what we want is the query below.
</para>

<programlisting>
born-in($PERSON : person, $CITY : place),
located-in($CITY : containee, italy : container)?
</programlisting>

<para>
When this query is run the first predicate will produce a table of all
(person, city) combinations where the person is born in the city. This
is then passed to the second predicate, which takes out all rows where
the city is not located in Italy

<footnote><para>In practice the tolog query optimizer will start with
the second predicate and find all cities in Italy. It will then find
all the people born in those cities. It will do this because the other
way around will find lots of (person, city) combinations outside
Italy, which will be wasted because they have to be thrown away
afterwards. The result will of course be exactly the same. It may be
useful to be aware, however, that tolog will not necessarily run the
query exactly as given, but may transform it to a faster, but
equivalent, query before running it.</para></footnote>.
</para>

<para>
We can chain together as many predicates as we want in order to
express our query; there's nothing unusual in having 4-5 predicates
chained together to form a query.
</para>
</section>

<section>
<title>Projection</title>

<para>
In the above example we have the problem that the query returns both
the people and the city, while we are only interested in the people.
This can be solved by using projection, as follows:
</para>

<programlisting>
select $PERSON from
  born-in($PERSON : person, $CITY : place),
  located-in($CITY : containee, italy : container)?
</programlisting>

<para>
This tells the query engine that we're only interested in the
<symbol>PERSON</symbol> variable, and so it will produce a query
result that only consists of bindings of the <symbol>PERSON</symbol>
variable.  In this case, this is not so important, as we could just as
well have just ignored the bindings to the <symbol>CITY</symbol>
variable.  In some cases, however, ignoring one variable means
reducing the size of the query result (and avoiding duplicates), and
sometimes reducing the query result size quite dramatically. One
example is given below.
</para>

<programlisting>
select $B from
  instance-of($A, $B)?
</programlisting>

<para>
This query returns all the topic types used in the topic map, instead
of all class-instance pairs. The difference in the query result size
(not to mention performance) can be enormous, which is what makes this
useful.
</para>
</section>

<section>
<title>Counting</title>

<para>
Quite often, one uses queries to produce statistics about the data
contained in a topic map. If one wants to find out which Italian
opera composer was the most prolific, for example, one will want to
count the number of query results. tolog supports this, as the query
below shows.
</para>

<programlisting>
select $A, count($B) from
  composed-by($A : composer, $B : opera)?
</programlisting>

<para>
This query produces the full <symbol>A, B</symbol> table, then
replaces all rows that have the same value in the <symbol>A</symbol>
column by the number of such rows. The result is to count the number
of <symbol>B</symbol> matches per <symbol>A</symbol> match.
</para>
</section>

<section>
<title>Sorting</title>

<para>
While the query above does return the number of operas composed by
each composer, it does so in an order that is effectively random.
What we really want is to see the composers ordered by decreasing
number of composed operas. This can be achieved by writing the query
as shown below.
</para>

<programlisting>
  select $A, count($B) from
    composed-by($A : composer, $B : opera)
  order by $B desc?
</programlisting>

<para>
If the <symbol>desc</symbol> keyword is removed, the query results
will be ordered by ascending opera count instead of descending count.
The 'order by' clause can contain any number of variables, separated
by commas.
</para>

<para>
The <symbol>asc</symbol> keyword specifies that columns be ordered in
ascending order. This is also the default order.
</para>
</section>
</section>

<section>
<title>Advanced features</title>

<para>
What has been presented so far are only the simplest parts of tolog;
what one could call "basic tolog". tolog is much more powerful than
this, however, and that additional power is explored in this section.
</para>

<section>
<title>Dynamic occurrence predicates</title>

<para>
So far we have only looked at how to query on associations, but
occurrences also contain useful information, and in many cases we want
to retrieve or query on this information. This can be done in a manner
very similar to how associations are queried: the occurrence type is
used as the predicate. However, occurrences have a much simpler
structure, so for these we only need two positional parameters: first
the topic, then the occurrence value.
</para>

<para>
Finding the date of birth of every composer can be done as follows.
</para>

<programlisting>
instance-of($COMPOSER, composer), 
date-of-birth($COMPOSER, $DATE)?
</programlisting>

<para>
This query gives the following result.
</para>

<table>
<title>All composers and their dates of birth</title>
<tgroup cols="1">
<thead><row><entry>COMPOSER</entry> <entry>DATE</entry></row></thead>
<tbody>
<row><entry>Verdi, Giuseppe</entry>     <entry>1813 (10 Oct)</entry></row>
<row><entry>Ponchielli, Amilcar</entry> <entry>1834 (31 Aug)</entry></row>
<row><entry>Cilea, Francisco</entry>    <entry>1866 (23 Jul)</entry></row>
<row><entry>Boïto, Arrigo</entry>       <entry>1842 (24 Feb)</entry></row>
<row><entry>Catalani, Alfredo</entry>   <entry>1854 (19 Jun)</entry></row>
<row><entry>Puccini, Giacomo</entry>    <entry>1858 (22 Dec)</entry></row>
<row><entry>...</entry>                 <entry>...</entry></row>
</tbody>
</tgroup>
</table>

<para>
As with association predicates it is also possible to find the date of
birth of a specific composer, or to find all composers born on a
particular date. To do the latter we write:
</para>

<programlisting>
date-of-birth($PERSON, "1867 (24 Mar)")?
</programlisting>

<para>
This will find all topics which have this particular value for this
particular occurrence type (though of course only people have dates of
birth in this topic map), regardless of whether they are composers or
not. As it turns out, only Guido Menasci has this value, and he's a
<symbol>librettist</symbol>.
</para>

<para>
Note that locators are treated the same way as ordinary strings, which
means that to find all topics whose home pages are
<symbol>http://www.puccini.it</symbol>, you can use the following query.
</para>

<programlisting>
homepage($TOPIC, "http://www.puccini.it")?
</programlisting>

<para>
This finds all topics with a <symbol>homepage</symbol> occurrence
whose locator is the URI <symbol>http://www.puccini.it</symbol>. This
turns out to produce the results shown below.
</para>

<table>
<title>All topics with http://www.puccini.it homepage</title>
<tgroup cols="1">
<thead><row><entry>TOPIC</entry></row></thead>
<tbody>
<row><entry>Centro studi Giacomo Puccini</entry></row>
</tbody>
</tgroup>
</table>
</section>

<section>
<title>OR</title>

<para>
Quite often one may want to include information that matches either
one condition OR another condition. If, for example, we want to find
all operas which had their premiere in a particular city there are two
ways to do that. Usually we know which theatre the opera had its
premiere in, and in these cases the premiere is connected to that
theatre, and the theatre is connected with the city. In some cases,
however, all we know is the city, and in these cases the premiere is
directly connected with the city. Therefore, if we want to find all
operas which premiered in Milano<footnote><para>The traditional
English perversion of this is 'Milan'.</para></footnote>, we have to
do as shown below.
</para>

<programlisting>
select $OPERA from
  { premiere($OPERA : opera, milano : place) | 
    premiere($OPERA : opera, $THEATRE : place), 
    located-in($THEATRE : containee, milano : container) }?
</programlisting>

<para>
Here matches will be accepted so long as they satisfy
<emphasis>one</emphasis> of the branches inside the curly braces,
where the branches are separated by <symbol>|</symbol> characters.
Other predicates can be used in front of and after the curly braces,
and the braces can be nested arbitrarily deep. The result is shown
below.
</para>

<table>
<title>Operas premiered in Milano</title>
<tgroup cols="1">
<thead><row><entry>OPERA</entry></row></thead>
<tbody>
<row><entry>Il sindaco babbeo</entry></row>
<row><entry>Melenis</entry></row>
<row><entry>La Falce</entry></row>
<row><entry>I Cavalieri di Ekebù</entry></row>
<row><entry>Turandot</entry></row>
<row><entry>Marcella</entry></row>
<row><entry>...</entry></row>
</tbody>
</tgroup>
</table>

<para>
This capability is essentially the same as the boolean operator
<symbol>OR</symbol> in other languages, as it allows tolog to return
results where the criteria are true if <symbol>{ A | B }</symbol>.
</para>

<section id="sect-nonfailing-clause">
<title>Non-failing clauses</title>

<para>
A closely related function is what is known as <firstterm>non-failing
clauses</firstterm>; that is, a clause that will produce a value for a
variable if it can, but if it cannot still won't cause the query to
fail. This is useful when selecting optional values which are intended
to be used for display purposes.
</para>

<para>
One example might be if we want to all operas and for each the theatre
in which it had its premiere. If we don't know where it had its
premiere we still want to show the opera, but we'll leave out the
theatre. This is easily done as follows, by including the optional
part of the query in curly braces, without any alternative branches.
</para>

<programlisting>
instance-of($OPERA, opera),
{ premiere($OPERA : opera, $THEATRE : place) }?
</programlisting>

<para>
As you'll see if you try it, this query also returns matches where
<symbol>THEATRE</symbol> is bound to a city, since nothing in the
query says that it has to be bound to a theatre (tolog completely
ignores the meaning of variable names), and operas also have this
association with cities. So we have to add a condition that the
<symbol>THEATRE</symbol> actually be an instance of the type
<symbol>theatre</symbol>, as shown below.
</para>

<programlisting>
instance-of($OPERA, opera),
{ premiere($OPERA : opera, $THEATRE : place), 
  instance-of($THEATRE, theatre) }?
</programlisting>

<para>
This query gives the desired result, which is shown below.
</para>

<table>
<title>Operas and premiere theatres</title>
<tgroup cols="1">
<thead><row><entry>THEATRE</entry> <entry>OPERA</entry></row></thead>
<tbody>

<row><entry>Teatro Argentina</entry>        <entry>I due foscari</entry></row>
<row><entry>Teatro Sociale di Lecco</entry> <entry>Il parlatore eterno</entry></row>
<row><entry>Teatro La Fenice</entry>        <entry>Attila</entry></row>
<row><entry>Teatro alla Scala</entry>       <entry>Madame Butterfly</entry></row>
<row><entry>null</entry>                    <entry>Marina</entry></row>
<row><entry>null</entry>                    <entry>Il sindaco babbeo</entry></row>
<row><entry>...</entry>                     <entry>...</entry></row>
</tbody>
</tgroup>
</table>
</section>
</section>

<section>
<title>Using negation</title>

<para>
tolog supports negation, even though negation in logical querying is
not at all straightforward. To take an example imagine running the
query below.
</para>

<programlisting>
not(born-in(milano : place, $A : person))?
</programlisting>

<para>
What is this query going to return? All topics that have no born-in
association with Milano?  All person topics? An infinite number of
topics, representing everything that wasn't born in Milano? What about
the persons which have no born-in association yet, but which were
actually born in Milano? And so on.
</para>

<para>
The approach taken in tolog is that the <symbol>not</symbol> operator
is used as a filter. You must specify a start set, and the query
processor will then eliminate the members of the start set which match
the condition specified in the <symbol>not</symbol> clause. The
example below shows the people in the topic map that were not born in
Italy.
</para>

<programlisting>
instance-of($PERSON, person),
not(born-in($PLACE : place, $PERSON : person),
    located-in($PLACE : containee, italy : container))?
</programlisting>

<para>
This gives the results shown below.
</para>

<table>
<title>Non-Italian people</title>
<tgroup cols="1">
<thead><row><entry>PERSON</entry></row></thead>
<tbody>
<row><entry>Guglielmo Ratcliff</entry></row>
<row><entry>Manzoni, Alessandro</entry></row>
<row><entry>Comtessa di Coigny</entry></row>
<row><entry>Sardou, Victorien</entry></row>
<row><entry>...</entry></row>
</tbody>
</tgroup>
</table>

<para>
One thing that stands out here is that Alessandro Manzoni actually
<emphasis>is</emphasis> Italian. So why was he included? Well, this
query is subtly different from asking for the composers born somewhere
not in Italy. This query will also find composers which have no
<symbol>born-in</symbol> association, or who are born somewhere that
has no <symbol>located-in</symbol> association. It turns out that
Alessandro Manzoni has no <symbol>born-in</symbol> association, and so
he is "not born in Italy". To eliminate this type of match we would
have had to pick out the country where the person is born and use
<symbol>/=</symbol> to make sure that it was not Italy. On the other
hand, that would have left out Victorien Sardou, who is a person (with
no <symbol>born-in</symbol> association) and not Italian. (So why do
we say all this? Simply to emphasise that <symbol>not</symbol> is
subtly different from true negation. It might not mean what you think
it means.)
</para>

<para>
Another thing to note is that although this query uses the
<symbol>PLACE</symbol> variable that variable is not actually bound in
the query. That is because every <symbol>COMPOSER</symbol> that
creates a match for <symbol>PLACE</symbol> is eliminated, leaving only
those which don't. So while the query result will contain a
<symbol>PLACE</symbol> column, that column will be empty.
</para>
</section>

<section>
<title>Comparison predicates</title>

<para>
tolog also supports the comparison operators familiar from many other
languages. We have already seen <symbol>/=</symbol>, but there are
many more. For example, there is also <symbol>=</symbol>, which means
the opposite of what <symbol>/=</symbol> does. That is, it is true
when the values on both sides are equal. This means that we can do a
query to find operas which premiered on a particular day, as in:
</para>

<programlisting>
premiere-date($OPERA, $DATE),
$DATE = "1870 (22 Feb)"?
</programlisting>

<para>
This will give us the (single) opera premiered on this date, according
to the Opera topic map. It should be noted that in most cases the
<symbol>=</symbol> comparator is not necessary, since if a variable is
equal to another variable or a literal we can just replace all
occurrences of the variable with what it is supposed to be equal to.
This gives us simpler queries, like the one below.
</para>

<programlisting>
premiere-date($OPERA, "1870 (22 Feb)")?
</programlisting>

<para>
However, this comparator <emphasis>does</emphasis> have its uses,
such as when defining an inference rule (see following section) that
will connect a topic to all topics matching some condition as well as
the topic itself. To put it another way: it's useful to know that this
predicate exists, but be aware that you rarely need it.
</para>

<para>
There are also four other comparison predicates
(<symbol>&lt;</symbol>, <symbol>&gt;</symbol>, <symbol>&lt;=</symbol>,
<symbol>&gt;=</symbol>) which only compare strings, and, at the
moment, compare strings as strings. This makes it possible to do a
query to find all operas premiered in the 19th century, as follows:
</para>

<programlisting>
premiere-date($OPERA, $DATE),
$DATE &lt; "1900"?
</programlisting>

<para>
This will do a string comparison on the dates, and filter out
everything premiered in the 20th century. Note that these four
predicates do not compare anything other than strings (such as
topics), and that they require both values they are comparing to be
bound.
</para>
</section>

<section>
<title>Inference rules</title>

<para>
In many cases there are implicit relationships in the topic map not
stated as associations, but which can be deduced from more basic
relationships that are given explicitly as associations. Inference
rules provide a way to capture these implicit relationships through
the declaration of a simple rule. The rule can then be used throughout
an application to simplify queries.
</para>

<para>
We can say that if an opera composer was a pupil of another composer,
or if the composer wrote operas based on the work of another person,
that other person or composer influenced the composer. We can of
course query for this, but if we want to use the influenced-by
relationship in several larger queries this quickly gets awkward.
Instead, we can capture the relationship in an inference rule, as
shown below.
</para>

<programlisting>
influenced-by($A, $B) :- {
  pupil-of($A : pupil, $B : teacher) |
  composed-by($OPERA : opera, $A : composer),
  based-on($OPERA : result, $WORK : source),
  written-by($WORK : work, $B : writer)
}.
</programlisting>

<para>
This rule has now created a new predicate called
<symbol>influenced-by</symbol>, which can be used in queries. Let's
say that we want to find every case where an Italian opera composer
was influenced by someone who was not himself Italian. We can now do
this as shown below.
</para>

<programlisting>
instance-of($COMPOSER, composer),
influenced-by($COMPOSER, $INFLUENCE),
born-in($INFLUENCE : person, $PLACE : place),
not(located-in($PLACE : containee, italy : container))?
</programlisting>

<para>
We skip verifying that the composer was born in Italy, since all
composers in this topic map are born in Italy. This gives the result
shown below.
</para>

<table>
<title>Foreign influences on Italian opera</title>
<tgroup cols="1">
<thead><row><entry>COMPOSER</entry> <entry>INFLUENCE</entry></row></thead>
<tbody>
<row><entry>Verdi, Giuseppe</entry>     <entry>Méry, Joseph</entry></row>
<row><entry>Ponchielli, Amilcar</entry> <entry>Scribe, Eugène</entry></row>
<row><entry>Cilea, Francesco</entry>    <entry>Daudet, Alphonse</entry></row>
<row><entry>Cilea, Francesco</entry>    <entry>Scribe, Eugène</entry></row>
<row><entry>Cilea, Francesco</entry>    <entry>Mélésville</entry></row>
</tbody>
</tgroup>
</table>

<para>
Inference rules can also use other influence rules, which means that
one can build large reasoning structures by layering the inference
rules on top of each other. Inference rules can also use themselves,
which makes it possible to define recursive inference rules, for
example for traversing hierarchical association structures.
</para>

<para>
Note that tolog has the same comment syntax as LTM (that is, comments
begin with <symbol>/*</symbol> and end with <symbol>*/</symbol>). This
can be used for example to document inference rules, as shown below.
</para>

<programlisting>

/* connects opera composers (A) with the people who influenced them
   (B), either by being their teachers or by writing works on which
   the composer based operas */

influenced-by($A, $B) :- {
  pupil-of($A : pupil, $B : teacher) |
  composed-by($OPERA : opera, $A : composer),
  based-on($OPERA : result, $WORK : source),
  written-by($WORK : work, $B : writer)
}.
</programlisting>

<para>
In the example above it may look as though the bodies of inference
rules should be wrapped in curly braces, like blocks in Java or C, but
the curlies are there because the entire rule is one big OR clause. If
we drop the <symbol>pupil-of</symbol> part the rule would look as
shown below. If we had wrapped this in curly braces we would have
turned the body of the rule into a non-failing clause (<xref
linkend="sect-nonfailing-clause"/>), allowing it to match topics which
don't actually satisfy the rule. So beware of this.
</para>

<programlisting>
influenced-by($A, $B) :-
  composed-by($OPERA : opera, $A : composer),
  based-on($OPERA : result, $WORK : source),
  written-by($WORK : work, $B : writer).      
</programlisting>

<para>
As said above, tolog supports recursive inference rules, which are
typically used to traverse hierarchies, or to query transitive
association types. An example of such an inference rule, for a generic
parent-child relationship, might look as follows:
</para>

<programlisting>
descendant-of($ANC, $DES) :- {
  parent-child($ANC : parent, $DES : child) |
  parent-child($ANC : parent, $MID : child), descendant-of($MID, $DES)
}.
</programlisting>

<para>
Notice how the rule is essentially a formalization of what it means to
be a descendant. That is, either the ancestor is the parent of the
descendant, or the ancestor is the parent of some middle topic of
which the descendant is a descendant. This explanation may sound a
little strange, and that's because of the recursion in the last step.
</para>
</section>

<section>
<title>The built-in predicates</title>

<para>
The parts of tolog shown thus far only support querying on
type-instance relationships, associations with a specific structure,
and occurrences of specific types. It is impossible to do queries like
"find all association types", "find all associations between topics X
and Y", "find all occurrences of topic Z", and so on with the parts of
tolog that have been explained thus far.
</para>

<para>
tolog has a number of built-in predicates like
<symbol>instance-of</symbol> that make it possible to do this kind of
query. These predicates are listed below, and more fully documented
in <ulink url="predicate-reference.html">The Built-in tolog Predicates
&#x2014; Reference Documentation</ulink>.
</para>

<itemizedlist>
<listitem><formalpara>
<title>association($ASSOC)</title>
<para>This predicate takes only one parameter and finds all
associations. Can be used to test whether a value is an association,
and to find all associations.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>association-role($ASSOC, $ROLE)</title>
<para>This predicate connects associations with their association
roles.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>base-locator($LOC)</title>
<para>Finds the base locator of the topic map.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>direct-instance-of($INSTANCE, $TYPE)</title>
<para>A variant of <symbol>instance-of</symbol> which connects a topic
with the topics it is explicitly said to be an instance of. In other
words, just like <symbol>instance-of</symbol>, except that it ignores
the superclass-subclass association.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>instance-of($INSTANCE, $TYPE)</title>
<para>This predicate connects a topic (INSTANCE) with every topic it
is an instance of (TYPE). A topic is considered to be an instance of
another if the other is explicitly set as the type, or if it is a
superclass of a topic that is set as the type.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>occurrence($TOPIC, $OCCURRENCE)</title>
<para>Connects occurrences with the topics they belong to.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>reifies($REIFIER, $REIFIED)</title>
<para>Connects topics (<symbol>REIFIER</symbol>) with the topic map
constructs (<symbol>REIFIED</symbol>) they reify.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>resource($OBJECT, $LOCATOR)</title>
<para>For any variant name or occurrence that has a locator
(<symbol>OBJECT</symbol>), finds that locator.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>role-player($ROLE, $PLAYER)</title>
<para>Connects association roles with the topic that plays the
role.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>scope($SCOPED, $THEME)</title>
<para>Connects topic names, occurrences, and associations with the
topics that make up the scope.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>item-identifier($OBJECT, $LOCATOR)</title>
<para>Finds the item identifiers of a topic map construct.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>subject-identifier($TOPIC, $LOCATOR)</title>
<para>Connects topics with their subject identifiers.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>subject-locator($TOPIC, $LOCATOR)</title>
<para>Connects a topic with its subject locator,
if it has one.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>topic($TOPIC)</title>
<para>Finds all topics in the topic map.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>topic-name($TOPIC, $NAME)</title>
<para>Connects topics with their topic names.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>topicmap($TOPICMAP)</title>
<para>Finds the topic map itself.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>type($TYPED, $TYPE)</title>
<para>Connects occurrences, associations, and association roles
(<symbol>TYPED</symbol>) with their type, if they have one.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>value($OBJECT, $VALUE)</title>
<para>Finds the string value of topic names, variant names, and
occurrences, if they have one.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>value-like($OBJECT, $SEARCHSTRING)</title>
<para>This predicate <emphasis>must</emphasis> have a bound value for
the <symbol>SEARCHSTRING</symbol> argument, and will do a full-text
search for topic map constructs that match the
<symbol>SEARCHSTRING</symbol>. This makes it possible to do full-text
searches in tolog queries.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>variant($BASENAME, $VARIANT)</title>
<para>Connects variants with the topic names they are contained in.</para>
</formalpara></listitem>

<listitem><formalpara>
<title>/=</title>
<para>Compares two values (both of which must be bound) to see if they
are the different; fails if the two values are equal.</para>
</formalpara></listitem>
</itemizedlist>

<para>
We can't give examples of the use of all of these predicates, since
there are so many of them, but at least we can show some. We can start
with "find all association types", which is given below., "find all
associations between topics X and Y", "find all occurrences of topic
Z"
</para>

<programlisting>
select $TYPE from
  association($ASSOC), type($ASSOC, $TYPE)?
</programlisting>

<para>
Finding all associations between topic 'x' and topic 'y' is quite
easy, though a bit more involved.
</para>

<programlisting>
select $ASSOC from
  role-player($ROLE1, x),
  association-role($ASSOC, $ROLE1),
  association-role($ASSOC, $ROLE2),
  role-player($ROLE2, y)?
</programlisting>

<para>
We can also find all occurrences of topic z quite easily, as shown
below.
</para>

<programlisting>
occurrence(z, $OCC)?
</programlisting>

<para>
The <symbol>/=</symbol> predicate allows an interesting class of
queries. We can control which values must be the same in a query,
simply by using the same variable, but we cannot force different
variables to have different values. This means that if we try to do a
query like "find all people born on the same day" we run into a quite
subtle problem. Below is the naive way to approach it.
</para>

<programlisting>
date-of-birth($PERSON1, $DATE),
date-of-birth($PERSON2, $DATE)?
</programlisting>

<para>
This runs, but does not produce the result we want, as can be seen
from the table below.
</para>

<table>
<title>People sharing birthdays</title>
<tgroup cols="1">
<thead><row><entry>PERSON1</entry> 
            <entry>DATE</entry> 
            <entry>PERSON2</entry></row></thead>
<tbody>
<row><entry>Benelli, Sem</entry> 
     <entry>1877 (10 Aug)</entry>
     <entry>Benelli, Sem</entry></row>
<row><entry>Ghislanzoni, Antonio</entry> 
     <entry>1824 (25 Nov)</entry>
     <entry>Ghislanzoni, Antonio</entry></row>
<row><entry>Coppée, François</entry> 
     <entry>1842 (26 Jan)</entry>
     <entry>Coppée, François</entry></row>
</tbody>
</tgroup>
</table>

<para>
Here tolog has discovered that if <symbol>PERSON1</symbol> is
'Benelli, Sam', <symbol>DATE</symbol> is '1877 (10 Aug)', and
<symbol>PERSON2</symbol> is 'Benelli, Sam', then our query criteria
are satisfied. In other words, tolog has found, as we asked it to,
that every person has the same birthdate as himself. We knew this all
along, of course, and did not want it in our query results at all, so
what we do now is to specify that we are not interested in matches
where there is only one person. This is done as below.
</para>

<programlisting>
date-of-birth($PERSON1, $DATE),
date-of-birth($PERSON2, $DATE),
$PERSON1 /= $PERSON2?
</programlisting>

<para>
This gives the result we wanted, which is shown below.
</para>

<table>
<title>People really sharing birthdays</title>
<tgroup cols="1">
<thead><row><entry>PERSON1</entry> 
            <entry>DATE</entry> 
            <entry>PERSON2</entry></row></thead>
<tbody>
<row><entry>Bognasco, G. di</entry> 
     <entry>(unknown)</entry>
     <entry>Lombardo, Carlo</entry></row>
<row><entry>Bognasco, G. di</entry> 
     <entry>(unknown)</entry>
     <entry>Franci, Arturo</entry></row>
<row><entry>Bognasco, G. di</entry> 
     <entry>(unknown)</entry>
     <entry>Vaucaire, Maurice</entry></row>
<row><entry>Duveyrier, Charles</entry> 
     <entry>1803</entry>
     <entry>Royer, Alphonse</entry></row>
<row><entry>Royer, Alphonse</entry> 
     <entry>1803</entry>
     <entry>Duveyrier, Charles</entry></row>
<row><entry>...</entry> 
     <entry>...</entry>
     <entry>...</entry></row>
</tbody>
</tgroup>
</table>

<para>
Again the results are somewhat disappointing. We see that there are
indeed two people who share the specified birth information, but in
their case we only know the year. We also see that a number of people
all have their birth date given as <symbol>"(unknown)"</symbol> and
since all these values are the same they are also returned as query
matches, though they are of course not guaranteed to have the same
birth date.
</para>
</section>

<section>
<title>Paging</title>

<para>
Sometimes we don't want all the results from a query, but only a
limited set of results. For example, we may only want to know the
answer to "who is the most prolific opera composer?" In this case, we
only want the first row of the results, and not the rest, however many
they may be. tolog supports this, through the <symbol>LIMIT</symbol>
keyword, as shown below.
</para>

<programlisting>
select $A, count($B) from
  composed-by($A : composer, $B : opera)
order by $B desc limit 1?
</programlisting>

<para>
This gives the result ("Verdi, Guiseppe", 28), but does not return any
of the other rows. Note that the <symbol>order by</symbol> is very
important. Without this we would have produced the rows in random
order, then only returned the first, which need not have been the row
for the most prolific composer.
</para>

<para>
The <symbol>LIMIT</symbol> keyword is mainly used as a performance
optimization in cases where a large number of results can be returned.
<symbol>LIMIT</symbol> allows the application to tell the query
processor the limit the number of results to a manageable number, and
this can have significant performance benefits in some cases.
</para>

<para>
Another use for <symbol>LIMIT</symbol> is when one wants to show a
paged list. That is, a query is run to show first results 1-10, then,
if the user wants to go further, 11-20, then, 21-30, and so on. tolog
can do this with <symbol>LIMIT</symbol> and <symbol>OFFSET</symbol>
together. Let's say we want to show operas, and we only want to show
the first page. We can then do as below.
</para>

<programlisting>
instance-of($OPERA, opera)
order by $OPERA limit 10?
</programlisting>

<para>
This gives us the first ten operas (note the <symbol>order by</symbol>
which guarantees a consistent ordering), and we can continue with the
below to get operas 11-20.
</para>

<programlisting>
instance-of($OPERA, opera)
order by $OPERA limit 10 offset 10?
</programlisting>

<para>
This query starts on row 10 (the first one did rows 0-9) according to
<symbol>OFFSET</symbol> and stops after 10 rows, according to
<symbol>LIMIT</symbol>. By increasing <symbol>OFFSET</symbol> to 20,
30, and so on we can continue stepping through the pages.
</para>
</section>
</section>

<section>
<title>Identifiers</title>

<para>
One thing that has been consistently glossed over so far is how topic
identifiers like <symbol>composer</symbol> actually refer to topics,
and how to refer to topics by means such as their subject identifiers.
Another issue we've ignored is how to actually make inference rule
definitions available to the query processor. This section deals with
both of those issues in more detail.
</para>

<section id="sect-topic-ref">
<title>Referring to topics</title>

<para>
There are several different ways of referring to topics (and other
topic map constructs, such as topic names, occurrences etc) in tolog,
although so far we have only seen topic IDs. Below is a complete list
of the different syntaxes.
</para>

<variablelist>
<varlistentry>
<term>id</term>
<listitem>
<para>This syntax is used to look up topics by their source locators.
The given ID is expanded to a full source locator by prepending the
base URI of the topic map being queried, followed by
<literal>#</literal>. If the topic being looked up did not originate
in the root document of the topic map (but instead came from a file
that was merged into it), this lookup will fail.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>i"uri"</term>
<listitem>
<para>Used to look up topics by their subject identifiers. The URI of
the identifier is given between the quotes, and is resolved relative to
the base URI of the topicmap.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>a"uri"</term>
<listitem>
<para>Used to look up topics by their subject locator. The URI of
the subject locator is given between the quotes, and is resolved relative to
the base URI of the topicmap.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>s"uri"</term>
<listitem>
<para>Used to look up topics by their source locators. The URI of
the locator is given between the quotes, and is resolved relative to
the base URI of the topicmap.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>@objid</term>
<listitem>
<para>Used to look up topics by their object ids. This is the fastest
method, and the one that is recommended when generating tolog
statements automatically. It does not make for readable queries,
however, and so should not be used for other purposes.
</para>
</listitem>
</varlistentry>
</variablelist>

<para>
This allows us to for example write a query that in any topic map will
find the topics at the top of the superclass-subclass hierarchy, as
shown below.
</para>

<programlisting>
select $TOP from
  i"http://www.topicmaps.org/xtm/1.0/core.xtm#superclass-subclass"(
    $TOP : i"http://www.topicmaps.org/xtm/1.0/core.xtm#superclass",
    $SUB : i"http://www.topicmaps.org/xtm/1.0/core.xtm#subclass"),
  not(i"http://www.topicmaps.org/xtm/1.0/core.xtm#superclass-subclass"(
    $OTHER : i"http://www.topicmaps.org/xtm/1.0/core.xtm#superclass",
    $TOP : i"http://www.topicmaps.org/xtm/1.0/core.xtm#subclass"))?
</programlisting>

<para>
Since this query uses the subject identifiers for the association type
and role types defined by XTM 1.0 this will work regardless of what
the XML IDs given to the topics are in any particular topic map. This
makes the query quite portable and robust. (Unfortunately, it also
makes the query almost entirely unreadable, but more about that in the
next section.)
</para>
</section>

<section>
<title>URI prefixes</title>

<para>
As noted above, giving URIs in full throughout a query quickly makes
the query so verbose as to be virtually unreadable. In order to solve
this, tolog has a feature called <firstterm>URI prefixes</firstterm>,
which allows the definition of an identifier prefix that can be
combined with a local name to create a full URI. Using this we can
rewrite the query from the previous section as shown below.
</para>

<programlisting>
using xtm for i"http://www.topicmaps.org/xtm/1.0/core.xtm#"
select $TOP from
  xtm:superclass-subclass($TOP : xtm:superclass, $SUB : xtm:subclass),
  not(xtm:superclass-subclass($OTHER : xtm:superclass,
                              $TOP : xtm:subclass))?
</programlisting>

<para>
This query defines the prefix <symbol>xtm</symbol> which is bound to
the URI <symbol>"http://www.topicmaps.org/xtm/1.0/core.xtm#"</symbol>,
and which is defined to be interpreted as subject identifier reference
(because of the <symbol>i</symbol> before the URI). Thus,
<symbol>xtm:subclass</symbol> is interpreted as
<symbol>i"http://www.topicmaps.org/xtm/1.0/core.xtm#subclass"</symbol>.
</para>

<para>
It is possible to define more than one prefix in a single query, and
it is also possible to bind prefixes to <symbol>a"..."</symbol> and
<symbol>s"..."</symbol> URIs.
</para>
</section>

<section>
<title>Modules</title>

<para>
Another thing we have glossed over so far is how to actually make an
inference rule available for use in queries. As it turns out, there
are several ways to do this, and we'll walk through them one by one.
The easiest is simply to put the rule into the query that uses it,
like shown below.
</para>

<programlisting>
influenced-by($A, $B) :- {
  pupil-of($A : pupil, $B : teacher) |
  composed-by($OPERA : opera, $A : composer),
  based-on($OPERA : result, $WORK : source),
  written-by($WORK : work, $B : writer)
}.

instance-of($COMPOSER, composer),
influenced-by($COMPOSER, $INFLUENCE),
born-in($INFLUENCE : person, $PLACE : place),
not(located-in($PLACE : containee, italy : container))?
</programlisting>

<para>
However, having to repeat the rule for every query that uses it is not
exactly a good code reuse strategy, so tolog also supports importing
rule sets from files. If the <symbol>influenced-by</symbol> rule is
stored in the file <filename>opera.tl</filename> in the same directory
as the <filename>opera.ltm</filename> topic map file the above query
can also be written as shown below.
</para>

<programlisting>
import "opera.tl" as opera

instance-of($COMPOSER, composer),
opera:influenced-by($COMPOSER, $INFLUENCE),
born-in($INFLUENCE : person, $PLACE : place),
not(located-in($PLACE : containee, italy : container))?
</programlisting>

<para>
What happens here is that the <symbol>import</symbol> statement
imports the rule file, which is stored as a module bound to the
<symbol>opera</symbol> prefix. The inference rules in the file then
turn into predicates in the module, and can be accessed through the
<symbol>opera</symbol> prefix.
</para>

<para> 
References to module files are first attempted loaded from the
CLASSPATH. If it was not found on the CLASSPATH then it is resolved
relative to the URI of the topic map, except inside module files where
it is resolved relative to the URI of the module file. (Module files
can import other module files.)  
</para>

</section>

<section>
<title>Scoping rules</title>

<para>
One thing we haven't looked at yet is what are known as
<firstterm>scoping rules</firstterm>; that is, the rules for which
declarations are visible where. Declarations in tolog are of two
types: inference rule declarations, and prefix declarations (whether
URI prefixes or module imports). The rules for all declarations are
the same, and they are as listed below.
</para>

<itemizedlist>
<listitem>
<para>Declarations included in a query only apply to that query.</para>
</listitem>
<listitem>
<para>Declarations included in a module are only visible in that
module, although rules defined in the module will be available through
the module prefix.</para>
</listitem>
<listitem>
<para>Declarations loaded into a query processor will be available
throughout the life of that processor. (See <xref linkend="sect-api"/>
for more information.)</para>
</listitem>
</itemizedlist>
</section>
</section>

<section>
<title>Running tolog queries</title>

<para>
This section explains how you can run tolog queries with Ontopia.
</para>

<section id="sect-plugin">
<title>The tolog plug-in</title>

<para>
The easiest way to get started with actually running tolog queries and
seeing the query results is to use the tolog plug-in in the Omnigator.
This plug-in appears as a "Query" link in the plug-in row of the
Omnigator's pages. Clicking on this link takes you to a page where you
can write tolog queries in a form and see them evaluated. The results
display as a table where each topic is linked back into the Omnigator.
</para>
</section>

<section>
<title>The 'tolog' tag library</title>

<para>
The Navigator Framework contains a tag library named 'tolog', which
consists of JSP tags specially designed for creating HTML output from
topic maps using tolog. The tag library allows queries to be run
against the topic map, and makes the resulting variable bindings
available as parameters for new queries or to be output, etc. For more
information on this, please consult The Navigator Framework &#x2014;
Developer's Guide.
</para>
</section>

<section id="sect-api">
<title>Using the query processor API</title>

<para>
The tolog query processor also has a Java API, which can be used to
evaluate queries and make use of the query results. The heart of this
API is the <interfacename>QueryProcessorIF</interfacename> interface,
which represents the query processor. Query processors can parse
queries and return objects representing them, and also take queries
and return query results (represented by
<interfacename>QueryResultIF</interfacename> objects). These
interfaces are all in the
<symbol>net.ontopia.topicmaps.query.core</symbol> package.
</para>

<para>
There are two tolog implementations in Ontopia. One of these works
directly against the API, and thus works for all the topic map engine
backends. However, it does not perform optimally for very large topic
maps stored in RDBMSs, and so there is a special implementation for
this backend. The <classname>QueryUtils</classname> class in the
<symbol>net.ontopia.topicmaps.query.utils</symbol> package can be used
to create query processors. It will automatically select the right
processor for your topic map, and lets you write code that is
independent of which backend you use.
</para>

<para>
The example below shows the implementation of the tolog plug-in in the
Omnigator, which is written using the API. The example has been
simplified somewhat, in order to make it more clear.
</para>

<example>
<title>The tolog plug-in</title>

<literallayout><![CDATA[
<p>Query:<br> <%= query %></p>

<%
 String query = request.getParameter("query");
 QueryProcessor proc = QueryUtils.getQueryProcessor(topicmap);
 QueryResultIF result = proc.execute(query);
 StringifierIF str = TopicStringifiers.getDefaultStringifier();
%>

<table class="text">
<tr><%
  String[] variables = result.getColumnNames();
  for (int ix = 0; ix < variables.length; ix++)
    out.write("<th>" + variables[ix]);
  }
%></tr>

<%
  Object[] row = new Object[result.getWidth()];
  while (result.next()) {
    out.write("<tr>");
    result.getValues(row);
    for (int ix = 0; ix < variables.length; ix++) {
      if (row[ix] == null)
        out.write("<td>null");
      else if (row[ix] instanceof TopicIF)
        out.write("<td><a href=\"../../models/topic_" + model + ".jsp?tm=" + tmid  + "&id=" + ((TopicIF) row[ix]).getObjectId() + "\">" +
                  str.toString(row[ix]) + "</a>");
      else
        out.write("<td>" + row[ix]);
      out.write("&nbsp;&nbsp;&nbsp;\n");
    }
    out.write("</tr>");
  }
  result.close();
%>
</table>
]]></literallayout>
</example>
</section>


<section>
<title>Parameters</title>

<para>
The query processor API supports parsing a query once and then running
the parsed query many times. This is supported through the
<methodname>parse(String query)</methodname> method of the
<interfacename>QueryProcessorIF</interfacename>. This returns an
object implementing <interfacename>ParsedQueryIF</interfacename>,
which can be executed many times.
</para>

<para>
Of course, executing the same query many times is not very
interesting; one might as well just cache the results and achieve the
same thing much more efficiently. However, tolog also supports
parameters to parsed queries. These are written with the
<symbol>%foo%</symbol> syntax that we saw used with the
<symbol>tm:tolog</symbol> tag above.
</para>

<para>
The <interfacename>ParsedQueryIF</interfacename> interface has two
methods named <methodname>execute</methodname>. One takes no arguments
and effectively reruns the same query. The other takes a
<interfacename>Map</interfacename> argument which maps parameter names
to their values. Using this, the same query can be run over and over
again with different parameters without having to pay the cost of
parsing and optimizing the query more than once.
</para>
</section>
</section>

<section>
<title>tolog updates</title>

<para>
In addition to querying the topic map to retrieve data tolog also
supports making modifications to the topic map. This section explains
how to use the <symbol>DELETE</symbol>, <symbol>UPDATE</symbol>,
<symbol>INSERT</symbol>, and <symbol>MERGE</symbol> statements, in
addition to the <symbol>SELECT</symbol> statement covered so far.
</para>

<para>
Note that in all of these statement types, topic references and prefix
declarations have exactly the same syntax as in
<symbol>SELECT</symbol> statements.
</para>

<section>
<title>The <symbol>DELETE</symbol> statement</title>

<para>
This statement is used to delete objects from the topic map. The
simplest form of delete statements is as follows:
</para>

<example>
<title>Deleting a topic</title>
<literallayout>delete foo</literallayout>
</example>

<para>
This would delete the topic map object with the ID
<symbol>foo</symbol>. If it is a topic map everything in the topic map
will be deleted. If it is an association, the association and all its
roles will be deleted. If it's a topic the topic and all its names,
occurrences, and all the associations it plays roles in will be
deleted. It will also be removed as a reifier, a topic type, and from
scopes, and statements typed with the topic will also be deleted.
</para>

<para>
It's possible to run a query to delete things, as follows:
</para>

<example>
<title>Deleting all person topics</title>
<literallayout>delete $PERSON from
  instance-of($PERSON, person)
</literallayout>
</example>

<para>
The <symbol>from</symbol> part of the query is the same as for
<symbol>SELECT</symbol> statements, and so the above would find all
topics of type <symbol>PERSON</symbol> and delete them. Any number of
variables and topic references are allowed in the
<symbol>delete</symbol> clause.
</para>

<para>
Finally, there is a third form of <symbol>DELETE</symbol> statements,
which calls a function to remove a value from a property. Here is an
example, removing all Wikipedia PSIs from all topics in the topic map:
</para>

<example>
<title>Removing Wikipedia PSIs</title>
<literallayout>import "http://psi.ontopia.net/tolog/string/" as str
  delete subject-identifier($TOPIC, $PSI) from
  subject-identifier($TOPIC, $PSI),
  str:starts-with($PSI, "http://en.wikipedia.org/wiki/")
</literallayout>
</example>

<para>
The deletion functions available in tolog are:
</para>

<informaltable>
<tgroup cols="3">
<thead>
<row>
  <entry>Function</entry>
  <entry>Parameters</entry>
  <entry>Meaning</entry>
</row>
</thead>
<tbody>
<row>
  <entry>subject-identifier</entry>
  <entry>topic, locator</entry>
  <entry>Removes the locator as a subject identifier for the topic.</entry>
</row>
<row>
  <entry>subject-locator</entry>
  <entry>topic, locator</entry>
  <entry>Removes the locator as a subject locator for the topic.</entry>
</row>
<row>
  <entry>item-identifier</entry>
  <entry>object, locator</entry>
  <entry>Removes the locator as an item identifier for the object.</entry>
</row>
<row>
  <entry>direct-instance-of</entry>
  <entry>topic, topic</entry>
  <entry>Removes the second topic as an a topic type of the first topic.</entry>
</row>
<row>
  <entry>scope</entry>
  <entry>statement, topic</entry>
  <entry>Removes the topic from the scope of the statement.</entry>
</row>
<row>
  <entry>reifies</entry>
  <entry>statement, topic</entry>
  <entry>Removes the topic as a reifier of the statement.</entry>
</row>  
</tbody>
</tgroup>
</informaltable>
</section>

<section>
<title>The <symbol>INSERT</symbol> statement</title>

<para>
The <symbol>INSERT</symbol> statement is used to add new information
to the topic map. In its simplest form it looks like this:
</para>

<example>
<title>Adding a new topic</title>
<literallayout>
INSERT
  tolog-updates isa update-language;
    - "tolog updates".
</literallayout>
</example>

<para>
Basically, after the <symbol>INSERT</symbol> keyword follows topic map
data in <ulink url="http://www.isotopicmaps.org/ctm/">CTM</ulink>
syntax. Note that it is possible to use the CTM wildcard syntax to
create new topics without giving them explicit IDs in the CTM
fragment. Prefixes declared for the tolog query can also be used in
the CTM fragment.
</para>

<para>
There is another more powerful form of the <symbol>INSERT</symbol>
statement which runs a query and instantiates the CTM part once for
each row in the query result. An example of this might be as follows:
</para>

<example>
<title>Adding Wikipedia PSIs</title>
<literallayout>import "http://psi.ontopia.net/tolog/string/" as str
  insert $topic $psi . from
  article-about($topic, $psi),
  str:starts-with($psi, "http://en.wikipedia.org/wiki/")
</literallayout>
</example>

<para>
For every <symbol>article-about</symbol> occurrence which references a
Wikipedia article this statement adds the URI of the article as a
subject identifier of the topic.
</para>
</section>

<section>
<title>The <symbol>UPDATE</symbol> statement</title>

<para>
The <symbol>UPDATE</symbol> statement makes it possible to change the
values of some properties in the topic map. The statement has two
forms, of which the simplest is this:
</para>

<example>
<title>Simple update</title>
<literallayout>update value(@2312, "Ontopia")</literallayout>
</example>

<para>
The above statement sets the string value of the object with ID
<symbol>2312</symbol> to <literal>"Ontopia"</literal>. It is also
possible to run a query to find the objects to change (and their
values), as follows:
</para>

<example>
<title>Query update</title>
<literallayout>update value($TN, "Ontopia") from
  topic-name(oks, $TN)
</literallayout>
</example>

<para>
The available update functions are:
</para>

<informaltable>
<tgroup cols="3">
<thead>
<row>
  <entry>Function</entry>
  <entry>Parameters</entry>
  <entry>Meaning</entry>
</row>
</thead>
<tbody>
<row>
  <entry>value</entry>
  <entry>object, string</entry>
  <entry>Sets the string value of the object, which must be a topic
  name, variant name, or occurrence.</entry>
</row>
<row>
  <entry>resource</entry>
  <entry>object, locator</entry>
  <entry>Sets the value of the object to the given locator (and also
  changes the datatype to URI), where the object must be a variant
  name or an occurrence.</entry>
</row>  
</tbody>
</tgroup>
</informaltable>
</section>

<section>
<title>The <symbol>MERGE</symbol> statement</title>

<para>
The <symbol>MERGE</symbol> statement can be used to merge topics
either by running a query or directly, as in the example below.
</para>

<example>
<title>Merging two topics</title>
<literallayout>merge topic1, topic2</literallayout>
</example>

<para>
It's also possible to find the topics to merge by running a query, as
in the following:
</para>

<example>
<title>Merging by email</title>
<literallayout>merge $T1, $T2 from
  email($T1, $EMAIL),
  email($T2, $EMAIL)</literallayout>
</example>

<para>
Rows where <symbol>T1</symbol> and <symbol>T2</symbol> refer to the
same topic are ignored.
</para>
</section>
</section>

<section>
<title>Further reading</title>

<para>
The most detailed description of tolog can be found in
<citetitle><ulink
url="http://www.ontopia.net/topicmaps/materials/tolog-spec.html">tolog
specification</ulink></citetitle>.
</para>

<para>The <citetitle><ulink
url="http://www.ontopia.net/topicmaps/materials/extending-tolog.html">Extending
tolog</ulink></citetitle> conference paper from Extreme Markup 2003
has more background on why tolog was extended from version 0.1 to 1.0,
and the design issues faced in that process.</para>

<para>The original paper on tolog is <citetitle><ulink
url="http://www.ontopia.net/topicmaps/materials/tolog.html">tolog - A
topic map query language</ulink></citetitle>, from XML Europe
2001.</para>

<para>More about tolog updates can be found in <ulink
url="http://www.tmra.de/2009/talks/tolog_updates">the TMRA 2009
paper</ulink>.</para>
</section>

</article>
